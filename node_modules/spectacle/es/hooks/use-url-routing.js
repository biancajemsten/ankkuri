function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import * as React from 'react';
import { createBrowserHistory } from 'history';
import * as queryString from 'query-string';
import { DEFAULT_SLIDE_ELEMENT_INDEX, DEFAULT_SLIDE_INDEX } from '../utils/constants';
export default function useUrlRouting(options) {
  var dispatch = options.dispatch,
      slideElementMap = options.slideElementMap,
      currentSlide = options.currentSlide,
      currentSlideElement = options.currentSlideElement,
      currentPresenterMode = options.currentPresenterMode,
      currentOverviewMode = options.currentOverviewMode,
      currentExportMode = options.currentExportMode,
      currentPrintMode = options.currentPrintMode,
      loop = options.loop,
      animationsWhenGoingBack = options.animationsWhenGoingBack,
      onUrlChange = options.onUrlChange;
  var history = React.useRef(createBrowserHistory());
  var numberOfSlides = React.useMemo(function () {
    return Object.getOwnPropertyNames(slideElementMap).length;
  }, [slideElementMap]);
  var countSlideElements = React.useCallback(function (slideNumber) {
    return slideElementMap[slideNumber];
  }, [slideElementMap]);
  var isSlideOutOfBounds = React.useCallback(function (proposedSlideNumber) {
    return isNaN(proposedSlideNumber) || numberOfSlides - 1 < proposedSlideNumber;
  }, [numberOfSlides]);
  var isSlideElementOutOfBounds = React.useCallback(function (proposedSlideElementNumber, slideElementsLength) {
    var val = isNaN(proposedSlideElementNumber) || proposedSlideElementNumber >= slideElementsLength || proposedSlideElementNumber < DEFAULT_SLIDE_ELEMENT_INDEX;
    return val;
  }, []);
  var stateFromUrl = React.useCallback(function (url) {
    var query = queryString.parse(url);
    var immediate = Boolean(query.immediate);
    var presenterMode = Boolean(query.presenterMode);
    var exportMode = Boolean(query.exportMode);
    var printMode = Boolean(query.printMode);
    var overviewMode = Boolean(query.overviewMode);
    var proposedSlideNumber = parseInt(query.slide, 10);
    var proposedSlideElementNumber = parseInt(query.slideElement, 10);
    var slideNumber = isSlideOutOfBounds(proposedSlideNumber) ? DEFAULT_SLIDE_INDEX : proposedSlideNumber;
    var slideElementsLength = countSlideElements(slideNumber);
    var slideElementNumber = isSlideElementOutOfBounds(proposedSlideElementNumber, slideElementsLength) ? DEFAULT_SLIDE_ELEMENT_INDEX : proposedSlideElementNumber;

    if (overviewMode && presenterMode) {
      throw new Error('Presenter Mode and Overview Mode cannot be used at the same time.');
    }

    return {
      immediate: immediate,
      presenterMode: presenterMode,
      overviewMode: overviewMode,
      proposedSlideNumber: proposedSlideNumber,
      proposedSlideElementNumber: proposedSlideElementNumber,
      slideNumber: slideNumber,
      slideElementNumber: slideElementNumber,
      exportMode: exportMode,
      printMode: printMode
    };
  }, [countSlideElements, isSlideElementOutOfBounds, isSlideOutOfBounds]);
  var goToSlide = React.useCallback(function (slideNumber) {
    var qs = queryString.stringify({
      presenterMode: currentPresenterMode || undefined,
      overviewMode: currentOverviewMode || undefined,
      exportMode: currentExportMode || undefined,
      immediate: true,
      slide: slideNumber,
      slideElement: DEFAULT_SLIDE_ELEMENT_INDEX,
      printMode: currentPrintMode || undefined
    });
    history.current.push("?".concat(qs));
  }, [currentPresenterMode, currentOverviewMode, currentExportMode, currentPrintMode]);
  var onHistoryChange = React.useCallback(function () {
    var _stateFromUrl = stateFromUrl(window.location.search),
        slideNumber = _stateFromUrl.slideNumber,
        slideElementNumber = _stateFromUrl.slideElementNumber,
        proposedSlideNumber = _stateFromUrl.proposedSlideNumber,
        proposedSlideElementNumber = _stateFromUrl.proposedSlideElementNumber,
        presenterMode = _stateFromUrl.presenterMode,
        overviewMode = _stateFromUrl.overviewMode,
        immediate = _stateFromUrl.immediate,
        exportMode = _stateFromUrl.exportMode,
        printMode = _stateFromUrl.printMode;
    /**
     * If the proposed URL slide index is out-of-bounds or is not a valid
     * integer, navigate to the first slide. Do nothing if the proposed slide
     * number is the same as the current slide.
     */


    if (proposedSlideNumber !== slideNumber || proposedSlideElementNumber !== slideElementNumber) {
      var qs = queryString.stringify({
        slide: slideNumber,
        slideElement: slideElementNumber,
        immediate: immediate || undefined,
        presenterMode: presenterMode || undefined,
        overviewMode: overviewMode || undefined,
        exportMode: exportMode || undefined,
        printMode: printMode || undefined
      });
      history.current.replace("?".concat(qs));
      return;
    }

    var reverseDirection = slideNumber < currentSlide || slideElementNumber < currentSlideElement;
    var update = {
      slideNumber: slideNumber,
      slideElementNumber: slideElementNumber,
      reverseDirection: reverseDirection,
      immediate: immediate
    };
    dispatch({
      type: 'GO_TO_SLIDE',
      payload: _objectSpread({}, update, {
        presenterMode: presenterMode,
        overviewMode: overviewMode,
        exportMode: exportMode,
        printMode: printMode
      })
    });
    onUrlChange(update);
  }, [stateFromUrl, currentSlide, currentSlideElement, dispatch, onUrlChange]);
  var nextSafeSlide = React.useCallback(function () {
    if (currentSlide + 1 > numberOfSlides - 1 && loop) {
      return DEFAULT_SLIDE_INDEX;
    }

    return Math.min(currentSlide + 1, numberOfSlides - 1);
  }, [currentSlide, loop, numberOfSlides]);
  var navigateToNext = React.useCallback(function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        immediate = _ref.immediate;

    var slideElementsLength = countSlideElements(currentSlide);
    var atLastElement = currentSlideElement + 1 === slideElementsLength || slideElementsLength === 0;
    var atLastSlide = currentSlide + 1 === numberOfSlides || numberOfSlides === 0;
    var nextSafeSlideIndex = currentSlide;
    var nextSafeSlideElementIndex = DEFAULT_SLIDE_ELEMENT_INDEX;

    if (atLastElement && atLastSlide) {
      if (!loop) {
        return;
      }

      nextSafeSlideIndex = DEFAULT_SLIDE_INDEX;
      nextSafeSlideElementIndex = DEFAULT_SLIDE_ELEMENT_INDEX;
    } else if (atLastElement) {
      // advance to the next safe slide
      nextSafeSlideIndex = nextSafeSlide();
      nextSafeSlideElementIndex = DEFAULT_SLIDE_ELEMENT_INDEX;
    } else {
      // advance to the next slide element
      nextSafeSlideElementIndex = currentSlideElement + 1;
    }

    var qs = queryString.stringify({
      slide: nextSafeSlideIndex,
      slideElement: nextSafeSlideElementIndex,
      immediate: immediate || undefined,
      presenterMode: currentPresenterMode || undefined,
      overviewMode: currentOverviewMode || undefined,
      exportMode: currentExportMode || undefined,
      printMode: currentPrintMode || undefined
    });
    history.current.push("?".concat(qs));
  }, [countSlideElements, currentSlide, currentSlideElement, numberOfSlides, currentPresenterMode, currentOverviewMode, currentExportMode, currentPrintMode, loop, nextSafeSlide]);
  var previousSafeSlide = React.useCallback(function () {
    if (currentSlide - 1 < 0 && loop) {
      return numberOfSlides - 1;
    }

    return Math.max(0, currentSlide - 1);
  }, [currentSlide, loop, numberOfSlides]);
  var navigateToPrevious = React.useCallback(function () {
    var immediate = !animationsWhenGoingBack;
    var slideElementsLength = countSlideElements(currentSlide);
    var atNoElement = currentSlideElement === DEFAULT_SLIDE_ELEMENT_INDEX || slideElementsLength === 0;
    var atFirstSlide = currentSlide === 0 || numberOfSlides === 0;
    var previousSafeSlideIndex = currentSlide;
    var previousSafeSlideElementIndex = DEFAULT_SLIDE_ELEMENT_INDEX;

    if (atNoElement && atFirstSlide) {
      if (!loop) {
        return;
      }

      previousSafeSlideIndex = numberOfSlides - 1;
    } else if (currentSlideElement < 0) {
      // back up to the previous safe slide
      previousSafeSlideIndex = previousSafeSlide();
      previousSafeSlideElementIndex = countSlideElements(previousSafeSlideIndex) - 1;
    } else {
      // back up to the previous slide element
      previousSafeSlideElementIndex = currentSlideElement - 1;
    }

    var qs = queryString.stringify({
      slide: previousSafeSlideIndex,
      slideElement: previousSafeSlideElementIndex,
      immediate: immediate || undefined,
      presenterMode: currentPresenterMode || undefined,
      overviewMode: currentOverviewMode || undefined,
      exportMode: currentExportMode || undefined
    });
    history.current.push("?".concat(qs));
  }, [animationsWhenGoingBack, countSlideElements, currentSlide, currentSlideElement, numberOfSlides, currentPresenterMode, currentOverviewMode, currentExportMode, loop, previousSafeSlide]);
  React.useEffect(function () {
    var removeHistoryListener = history.current.listen(onHistoryChange);
    return function () {
      removeHistoryListener();
    };
  }, [onHistoryChange]);
  /**
   * In order for Deck to render the correct type of sub-deck,
   * we need for certain state from the url to be written to the
   * DeckContext. For example, we need to know whether or not this
   * browser is in presenter mode.
   */

  React.useEffect(function () {
    onHistoryChange();
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  var toggleMode = React.useCallback(function (s) {
    return dispatch({
      type: 'TOGGLE_MODE',
      payload: {
        mode: s
      }
    });
  }, [dispatch]);
  return {
    navigateToNext: navigateToNext,
    navigateToPrevious: navigateToPrevious,
    toggleMode: toggleMode,
    goToSlide: goToSlide
  };
}