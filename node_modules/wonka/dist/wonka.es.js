function pipe(source) {
  var args = arguments;
  var len = args.length;
  var x = source;
  for (var i = 1; i < len; i++) {
    x = args[i](x);
  }
  return x;
}

function __(tag, block) {
  block.tag = tag;
  return block;
}

function caml_array_sub(x, offset, len) {
  var result = new Array(len);
  var j = 0;
  var i = offset;
  while (j < len) {
    result[j] = x[i];
    j = (j + 1) | 0;
    i = (i + 1) | 0;
  }
  return result;
}

function app(_f, _args) {
  while (1) {
    var args = _args;
    var f = _f;
    var init_arity = f.length;
    var arity = 0 === init_arity ? 1 : init_arity;
    var d = (arity - args.length) | 0;
    if (0 === d) {
      return f.apply(null, args);
    } else if (d < 0) {
      _args = caml_array_sub(args, arity, 0 | -d);
      _f = f.apply(null, caml_array_sub(args, 0, arity));
      continue;
    } else {
      return (function(f, args) {
        return function(x) {
          return app(f, args.concat([x]));
        };
      })(f, args);
    }
  }
}

function _1(o, a0) {
  var arity = o.length;
  if (1 === arity) {
    return o(a0);
  } else {
    return (function curry_1(o, a0, arity) {
      switch (arity) {
        case 1:
          return o(a0);

        case 2:
          return function(param) {
            return o(a0, param);
          };

        case 3:
          return function(param, param$1) {
            return o(a0, param, param$1);
          };

        case 4:
          return function(param, param$1, param$2) {
            return o(a0, param, param$1, param$2);
          };

        case 5:
          return function(param, param$1, param$2, param$3) {
            return o(a0, param, param$1, param$2, param$3);
          };

        case 6:
          return function(param, param$1, param$2, param$3, param$4) {
            return o(a0, param, param$1, param$2, param$3, param$4);
          };

        case 7:
          return function(param, param$1, param$2, param$3, param$4, param$5) {
            return o(a0, param, param$1, param$2, param$3, param$4, param$5);
          };

        default:
          return app(o, [a0]);
      }
    })(o, a0, arity);
  }
}

function _3(o, a0, a1, a2) {
  var arity = o.length;
  if (3 === arity) {
    return o(a0, a1, a2);
  } else {
    return (function curry_3(o, a0, a1, a2, arity) {
      switch (arity) {
        case 1:
          return app(o(a0), [a1, a2]);

        case 2:
          return app(o(a0, a1), [a2]);

        case 3:
          return o(a0, a1, a2);

        case 4:
          return function(param) {
            return o(a0, a1, a2, param);
          };

        case 5:
          return function(param, param$1) {
            return o(a0, a1, a2, param, param$1);
          };

        case 6:
          return function(param, param$1, param$2) {
            return o(a0, a1, a2, param, param$1, param$2);
          };

        case 7:
          return function(param, param$1, param$2, param$3) {
            return o(a0, a1, a2, param, param$1, param$2, param$3);
          };

        default:
          return app(o, [a0, a1, a2]);
      }
    })(o, a0, a1, a2, arity);
  }
}

var undefinedHeader = [];

function some(x) {
  if (void 0 === x) {
    var block = [undefinedHeader, 0];
    block.tag = 256;
    return block;
  } else if (null !== x && x[0] === undefinedHeader) {
    var block$1 = [undefinedHeader, (x[1] + 1) | 0];
    block$1.tag = 256;
    return block$1;
  } else {
    return x;
  }
}

function valFromOption(x) {
  if (null !== x && x[0] === undefinedHeader) {
    var depth = x[1];
    if (0 === depth) {
      return;
    } else {
      return [undefinedHeader, (depth - 1) | 0];
    }
  } else {
    return x;
  }
}

function talkbackPlaceholder(param) {
  return 0;
}

function captureTalkback(source, sinkWithTalkback) {
  var talkback = [talkbackPlaceholder];
  return _1(source, function(signal) {
    if ('number' != typeof signal) {
      if (!signal.tag) {
        talkback[0] = signal[0];
      }
    }
    return sinkWithTalkback(signal, talkback[0]);
  });
}

function makeTrampoline(sink, f) {
  var state = [!1, !1, !1];
  return sink(
    __(0, [
      function(signal) {
        var match = state[1];
        if (signal) {
          state[0] = !0;
          return 0;
        } else if (match) {
          state[2] = !0;
          return 0;
        } else {
          state[2] = !0;
          state[1] = !0;
          while (state[2] && !state[0]) {
            var match$1 = f();
            if (void 0 !== match$1) {
              state[2] = !1;
              sink(__(1, [valFromOption(match$1)]));
            } else {
              state[0] = !0;
              sink(0);
            }
          }
          state[1] = !1;
          return 0;
        }
      }
    ])
  );
}

var observableSymbol =
  'function' == typeof Symbol
    ? Symbol.observable || (Symbol.observable = Symbol('observable'))
    : '@@observable';

function takeLast(max) {
  return function(source) {
    return function(sink) {
      var queue = new Array();
      return captureTalkback(source, function(signal, talkback) {
        if ('number' == typeof signal) {
          return makeTrampoline(sink, function() {
            return queue.shift();
          });
        } else if (signal.tag) {
          if (queue.length >= max && max > 0) {
            queue.shift();
          }
          queue.push(signal[0]);
          return talkback(0);
        } else {
          return talkback(0);
        }
      });
    };
  };
}

function fromListener(addListener, removeListener) {
  return function(sink) {
    var handler = function($$event) {
      return sink(__(1, [$$event]));
    };
    sink(
      __(0, [
        function(signal) {
          if (signal) {
            return _1(removeListener, handler);
          } else {
            return 0;
          }
        }
      ])
    );
    return _1(addListener, handler);
  };
}

var toPromise$1 = function toPromise(source) {
  return new Promise(function(resolve, param) {
    return _1(takeLast(1)(source), function(signal) {
      if ('number' == typeof signal) {
        return 0;
      } else if (signal.tag) {
        return resolve(signal[0]);
      } else {
        return signal[0](0);
      }
    });
  });
};

function subscribe(f) {
  return function(source) {
    var state = [talkbackPlaceholder, !1];
    _1(source, function(signal) {
      if ('number' == typeof signal) {
        state[1] = !0;
        return 0;
      } else if (signal.tag) {
        if (state[1]) {
          return 0;
        } else {
          f(signal[0]);
          return state[0](0);
        }
      } else {
        var x = signal[0];
        state[0] = x;
        return x(0);
      }
    });
    return [
      function(param) {
        if (state[1]) {
          return 0;
        } else {
          state[1] = !0;
          return state[0](1);
        }
      }
    ];
  };
}

function fromArray(arr) {
  return function(sink) {
    var size = arr.length;
    var index = [0];
    return makeTrampoline(sink, function() {
      if (index[0] < size) {
        var x = arr[index[0]];
        index[0] = (index[0] + 1) | 0;
        return some(x);
      }
    });
  };
}

function onPush(f) {
  return function(source) {
    return function(sink) {
      return _1(source, function(signal) {
        if ('number' != typeof signal) {
          if (signal.tag) {
            f(signal[0]);
          }
        }
        return sink(signal);
      });
    };
  };
}

function mergeMap(f) {
  return function(source) {
    return function(sink) {
      var state = [talkbackPlaceholder, new Array(), !1];
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          if (state[2]) {
            return 0;
          } else {
            state[2] = !0;
            if (0 === state[1].length) {
              return sink(0);
            } else {
              return 0;
            }
          }
        } else if (signal.tag) {
          if (state[2]) {
            return 0;
          } else {
            (innerSource = f(signal[0])),
              (talkback = [talkbackPlaceholder]),
              _1(innerSource, function(signal) {
                if ('number' == typeof signal) {
                  state[1] = state[1].filter(function(x) {
                    return x !== talkback[0];
                  });
                  if (state[2] && 0 === state[1].length) {
                    return sink(0);
                  } else {
                    return 0;
                  }
                } else if (signal.tag) {
                  if (0 !== state[1].length) {
                    sink(__(1, [signal[0]]));
                    return talkback[0](0);
                  } else {
                    return 0;
                  }
                } else {
                  var tb = signal[0];
                  talkback[0] = tb;
                  state[1] = state[1].concat(tb);
                  return tb(0);
                }
              });
            return state[0](0);
          }
        } else {
          var tb = signal[0];
          state[0] = tb;
          return tb(0);
        }
        var innerSource, talkback;
      });
      return sink(
        __(0, [
          function(signal) {
            if (signal) {
              state[1].forEach(function(talkback) {
                return talkback(1);
              });
              if (state[2]) {
                return 0;
              } else {
                state[2] = !0;
                state[0](1);
                state[1].forEach(function(talkback) {
                  return talkback(1);
                });
                state[1] = new Array();
                return 0;
              }
            } else if (state[2]) {
              return 0;
            } else {
              state[1].forEach(function(talkback) {
                return talkback(0);
              });
              return 0;
            }
          }
        ])
      );
    };
  };
}

function mergeAll(source) {
  return mergeMap(function(x) {
    return x;
  })(source);
}

function concatMap(f) {
  return function(source) {
    return function(sink) {
      var state = [new Array(), talkbackPlaceholder, talkbackPlaceholder, !1, !1, !1];
      var applyInnerSource = function(innerSource) {
        return _1(innerSource, function(signal) {
          if ('number' == typeof signal) {
            state[3] = !1;
            state[2] = talkbackPlaceholder;
            var match = state[0].shift();
            if (void 0 !== match) {
              return applyInnerSource(f(valFromOption(match)));
            } else if (state[5]) {
              return sink(0);
            } else {
              return 0;
            }
          } else if (signal.tag) {
            if (state[4]) {
              return 0;
            } else {
              sink(__(1, [signal[0]]));
              return state[2](0);
            }
          } else {
            var tb = signal[0];
            state[3] = !0;
            state[2] = tb;
            return tb(0);
          }
        });
      };
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          if (state[5]) {
            return 0;
          } else {
            state[5] = !0;
            if (
              !state[3] &&
              (function isEmpty(q) {
                return 0 === q.length;
              })(state[0])
            ) {
              return sink(0);
            } else {
              return 0;
            }
          }
        } else if (signal.tag) {
          if (state[5]) {
            return 0;
          } else {
            var x = signal[0];
            if (state[3]) {
              state[0].push(x);
            } else {
              applyInnerSource(f(x));
            }
            return state[1](0);
          }
        } else {
          var tb = signal[0];
          state[1] = tb;
          return tb(0);
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (signal) {
              state[2](1);
              if (state[5]) {
                return 0;
              } else {
                state[5] = !0;
                state[4] = !0;
                state[1](1);
                state[2] = talkbackPlaceholder;
                return 0;
              }
            } else if (state[5]) {
              return 0;
            } else {
              return state[2](0);
            }
          }
        ])
      );
    };
  };
}

function switchMap(f) {
  return function(source) {
    return function(sink) {
      var state = [talkbackPlaceholder, talkbackPlaceholder, !1, !1, !1];
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          if (state[4]) {
            return 0;
          } else {
            state[4] = !0;
            if (state[2]) {
              return 0;
            } else {
              return sink(0);
            }
          }
        } else if (signal.tag) {
          if (state[4]) {
            return 0;
          } else {
            if (state[2]) {
              state[1](1);
              state[1] = talkbackPlaceholder;
            }
            _1(f(signal[0]), function(signal) {
              if ('number' == typeof signal) {
                state[2] = !1;
                state[1] = talkbackPlaceholder;
                if (state[4]) {
                  return sink(0);
                } else {
                  return 0;
                }
              } else if (signal.tag) {
                if (state[3]) {
                  return 0;
                } else {
                  sink(__(1, [signal[0]]));
                  return state[1](0);
                }
              } else {
                var tb = signal[0];
                state[2] = !0;
                state[1] = tb;
                return tb(0);
              }
            });
            return state[0](0);
          }
        } else {
          var tb = signal[0];
          state[0] = tb;
          return tb(0);
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (signal) {
              state[1](1);
              if (state[4]) {
                return 0;
              } else {
                state[4] = !0;
                state[3] = !0;
                state[0](1);
                state[1] = talkbackPlaceholder;
                return 0;
              }
            } else {
              return state[1](0);
            }
          }
        ])
      );
    };
  };
}

var Types = 0;

var fromArray$2 = fromArray;

var fromList$2 = function fromList(ls) {
  return function(sink) {
    var value = [ls];
    return makeTrampoline(sink, function() {
      var match = value[0];
      if (match) {
        value[0] = match[1];
        return some(match[0]);
      }
    });
  };
};

var fromValue$2 = function fromValue(x) {
  return function(sink) {
    var ended = [!1];
    return sink(
      __(0, [
        function(signal) {
          if (signal || ended[0]) {
            return 0;
          } else {
            ended[0] = !0;
            sink(__(1, [x]));
            return sink(0);
          }
        }
      ])
    );
  };
};

var make$2 = function make(f) {
  return function(sink) {
    var teardown = [
      function() {
        return 0;
      }
    ];
    sink(
      __(0, [
        function(signal) {
          if (signal) {
            return teardown[0]();
          } else {
            return 0;
          }
        }
      ])
    );
    teardown[0] = f([
      function(value) {
        return sink(__(1, [value]));
      },
      function(param) {
        return sink(0);
      }
    ]);
    return 0;
  };
};

var makeSubject$2 = function makeSubject(param) {
  var state = [new Array(), !1];
  return [
    function(sink) {
      state[0] = state[0].concat(sink);
      return sink(
        __(0, [
          function(signal) {
            if (1 === signal) {
              state[0] = state[0].filter(function(x) {
                return x !== sink;
              });
              return 0;
            } else {
              return 0;
            }
          }
        ])
      );
    },
    function(value) {
      if (state[1]) {
        return 0;
      } else {
        state[0].forEach(function(sink) {
          return sink(__(1, [value]));
        });
        return 0;
      }
    },
    function(param) {
      if (state[1]) {
        return 0;
      } else {
        state[1] = !0;
        state[0].forEach(function(sink) {
          return sink(0);
        });
        return 0;
      }
    }
  ];
};

var empty$2 = function empty(sink) {
  sink(__(0, [talkbackPlaceholder]));
  return sink(0);
};

var never$2 = function never(sink) {
  return sink(__(0, [talkbackPlaceholder]));
};

var buffer$2 = function buffer(notifier) {
  return function(source) {
    return function(sink) {
      var state = [new Array(), talkbackPlaceholder, talkbackPlaceholder, !1];
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          if (state[3]) {
            return 0;
          } else {
            state[3] = !0;
            state[2](1);
            sink(__(1, [state[0]]));
            return sink(0);
          }
        } else if (signal.tag) {
          if (state[3]) {
            return 0;
          } else {
            state[0].push(signal[0]);
            return state[1](0);
          }
        } else {
          state[1] = signal[0];
          return _1(notifier, function(signal) {
            if ('number' == typeof signal) {
              if (state[3]) {
                return 0;
              } else {
                state[3] = !0;
                state[1](1);
                sink(__(1, [state[0]]));
                return sink(0);
              }
            } else if (signal.tag) {
              if (state[3]) {
                return 0;
              } else {
                sink(__(1, [state[0]]));
                state[0] = new Array();
                return state[2](0);
              }
            } else {
              state[2] = signal[0];
              return state[2](0);
            }
          });
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (state[3]) {
              return 0;
            } else if (signal) {
              state[3] = !0;
              state[1](1);
              return state[2](1);
            } else {
              return state[1](0);
            }
          }
        ])
      );
    };
  };
};

var combine$2 = function combine(sourceA) {
  return function(sourceB) {
    return function(sink) {
      var state = [talkbackPlaceholder, talkbackPlaceholder, void 0, void 0, !1, 0, !1];
      _1(sourceA, function(signal) {
        var match = state[3];
        if ('number' == typeof signal) {
          if (state[5] < 1) {
            state[5] = (state[5] + 1) | 0;
            return 0;
          } else if (state[6]) {
            return 0;
          } else {
            state[6] = !0;
            return sink(0);
          }
        } else if (signal.tag) {
          var a = signal[0];
          if (void 0 !== match) {
            if (state[6]) {
              return 0;
            } else {
              state[2] = some(a);
              state[4] = !1;
              return sink(__(1, [[a, valFromOption(match)]]));
            }
          } else {
            state[2] = some(a);
            state[4] = !1;
            return 0;
          }
        } else {
          state[0] = signal[0];
          return 0;
        }
      });
      _1(sourceB, function(signal) {
        var match = state[2];
        if ('number' == typeof signal) {
          if (state[5] < 1) {
            state[5] = (state[5] + 1) | 0;
            return 0;
          } else if (state[6]) {
            return 0;
          } else {
            state[6] = !0;
            return sink(0);
          }
        } else if (signal.tag) {
          var b = signal[0];
          if (void 0 !== match) {
            if (state[6]) {
              return 0;
            } else {
              state[3] = some(b);
              state[4] = !1;
              return sink(__(1, [[valFromOption(match), b]]));
            }
          } else {
            state[3] = some(b);
            state[4] = !1;
            return 0;
          }
        } else {
          state[1] = signal[0];
          return 0;
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (state[6]) {
              return 0;
            } else if (signal) {
              state[6] = !0;
              state[0](1);
              return state[1](1);
            } else if (state[4]) {
              return 0;
            } else {
              state[4] = !0;
              state[0](signal);
              return state[1](signal);
            }
          }
        ])
      );
    };
  };
};

var concatMap$2 = concatMap;

var concat$2 = function concat(sources) {
  return concatMap(function(x) {
    return x;
  })(fromArray(sources));
};

var concatAll$2 = function concatAll(source) {
  return concatMap(function(x) {
    return x;
  })(source);
};

var filter$2 = function filter(f) {
  return function(source) {
    return function(sink) {
      return captureTalkback(source, function(signal, talkback) {
        if ('number' == typeof signal || !signal.tag || f(signal[0])) {
          return sink(signal);
        } else {
          return talkback(0);
        }
      });
    };
  };
};

var map$2 = function map(f) {
  return function(source) {
    return function(sink) {
      return _1(source, function(signal) {
        var tmp;
        tmp =
          'number' == typeof signal ? 0 : signal.tag ? __(1, [f(signal[0])]) : __(0, [signal[0]]);
        return sink(tmp);
      });
    };
  };
};

var mergeMap$2 = mergeMap;

var merge$2 = function merge(sources) {
  return mergeMap(function(x) {
    return x;
  })(fromArray(sources));
};

var mergeAll$2 = mergeAll;

var flatten$2 = mergeAll;

var onEnd$2 = function onEnd(f) {
  return function(source) {
    return function(sink) {
      var ended = [!1];
      return _1(source, function(signal) {
        if ('number' == typeof signal) {
          if (ended[0]) {
            return 0;
          } else {
            ended[0] = !0;
            sink(signal);
            return f();
          }
        } else if (signal.tag) {
          return sink(signal);
        } else {
          var talkback = signal[0];
          return sink(
            __(0, [
              function(signal) {
                if (signal) {
                  if (ended[0]) {
                  } else {
                    ended[0] = !0;
                    f();
                  }
                }
                return talkback(signal);
              }
            ])
          );
        }
      });
    };
  };
};

var onPush$2 = onPush;

var tap$2 = onPush;

var onStart$2 = function onStart(f) {
  return function(source) {
    return function(sink) {
      return _1(source, function(signal) {
        if ('number' == typeof signal || signal.tag) {
          return sink(signal);
        } else {
          sink(signal);
          return f();
        }
      });
    };
  };
};

var sample$2 = function sample(notifier) {
  return function(source) {
    return function(sink) {
      var state = [
        !1,
        void 0,
        function(param) {
          return 0;
        },
        function(param) {
          return 0;
        }
      ];
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          state[0] = !0;
          state[3](1);
          return sink(0);
        } else if (signal.tag) {
          state[1] = some(signal[0]);
          return 0;
        } else {
          state[2] = signal[0];
          return 0;
        }
      });
      _1(notifier, function(signal) {
        var match = state[1];
        if ('number' == typeof signal) {
          state[0] = !0;
          state[2](1);
          return sink(0);
        } else if (signal.tag) {
          if (void 0 !== match && !state[0]) {
            state[1] = void 0;
            return sink(__(1, [valFromOption(match)]));
          } else {
            return 0;
          }
        } else {
          state[3] = signal[0];
          return 0;
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (signal) {
              state[0] = !0;
              state[2](1);
              return state[3](1);
            } else {
              state[2](0);
              return state[3](0);
            }
          }
        ])
      );
    };
  };
};

var scan$2 = function scan(f, seed) {
  return function(source) {
    return function(sink) {
      var acc = [seed];
      return _1(source, function(signal) {
        var tmp;
        if ('number' == typeof signal) {
          tmp = 0;
        } else if (signal.tag) {
          acc[0] = f(acc[0], signal[0]);
          tmp = __(1, [acc[0]]);
        } else {
          tmp = __(0, [signal[0]]);
        }
        return sink(tmp);
      });
    };
  };
};

var share$2 = function share(source) {
  var state = [new Array(), talkbackPlaceholder, !1];
  return function(sink) {
    state[0] = state[0].concat(sink);
    if (1 === state[0].length) {
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          state[0].forEach(function(sink) {
            return sink(0);
          });
          state[0] = new Array();
          return 0;
        } else if (signal.tag) {
          state[2] = !1;
          state[0].forEach(function(sink) {
            return sink(signal);
          });
          return 0;
        } else {
          state[1] = signal[0];
          return 0;
        }
      });
    }
    return sink(
      __(0, [
        function(signal) {
          if (signal) {
            state[0] = state[0].filter(function(x) {
              return x !== sink;
            });
            if (0 === state[0].length) {
              return state[1](1);
            } else {
              return 0;
            }
          } else if (state[2]) {
            return 0;
          } else {
            state[2] = !0;
            return state[1](signal);
          }
        }
      ])
    );
  };
};

var skip$2 = function skip(wait) {
  return function(source) {
    return function(sink) {
      var rest = [wait];
      return captureTalkback(source, function(signal, talkback) {
        if ('number' == typeof signal || !(signal.tag && rest[0] > 0)) {
          return sink(signal);
        } else {
          rest[0] = (rest[0] - 1) | 0;
          return talkback(0);
        }
      });
    };
  };
};

var skipUntil$2 = function skipUntil(notifier) {
  return function(source) {
    return function(sink) {
      var state = [!0, !1, !1, talkbackPlaceholder, talkbackPlaceholder];
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          if (state[0]) {
            state[4](1);
          }
          state[1] = !0;
          return sink(0);
        } else if (signal.tag) {
          if (state[0] && !state[1]) {
            return state[3](0);
          } else if (state[1]) {
            return 0;
          } else {
            state[2] = !1;
            return sink(signal);
          }
        } else {
          var tb = signal[0];
          state[3] = tb;
          return _1(notifier, function(signal) {
            if ('number' == typeof signal) {
              return 0;
            } else if (signal.tag) {
              state[0] = !1;
              return state[4](1);
            } else {
              var innerTb = signal[0];
              state[4] = innerTb;
              innerTb(0);
              return tb(0);
            }
          });
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (signal) {
              if (state[0]) {
                state[4](1);
              }
              state[1] = !0;
              return state[3](1);
            } else if (!state[2] && !state[1]) {
              state[2] = !0;
              return state[3](0);
            } else {
              return 0;
            }
          }
        ])
      );
    };
  };
};

var skipWhile$2 = function skipWhile(f) {
  return function(source) {
    return function(sink) {
      var skip = [!0];
      return captureTalkback(source, function(signal, talkback) {
        if ('number' == typeof signal || !signal.tag || !skip[0]) {
          return sink(signal);
        } else if (f(signal[0])) {
          return talkback(0);
        } else {
          skip[0] = !1;
          return sink(signal);
        }
      });
    };
  };
};

var switchMap$2 = switchMap;

var switchAll$2 = function switchAll(source) {
  return switchMap(function(x) {
    return x;
  })(source);
};

var take$2 = function take(max) {
  return function(source) {
    return function(sink) {
      var state = [0, talkbackPlaceholder];
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          if (state[0] < max) {
            state[0] = max;
            return sink(0);
          } else {
            return 0;
          }
        } else if (signal.tag) {
          if (state[0] < max) {
            state[0] = (state[0] + 1) | 0;
            sink(signal);
            if (state[0] === max) {
              sink(0);
              return state[1](1);
            } else {
              return 0;
            }
          } else {
            return 0;
          }
        } else {
          state[1] = signal[0];
          return 0;
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (state[0] < max) {
              if (signal) {
                state[0] = max;
                return state[1](1);
              } else {
                return state[1](0);
              }
            } else {
              return 0;
            }
          }
        ])
      );
    };
  };
};

var takeLast$2 = takeLast;

var takeUntil$2 = function takeUntil(notifier) {
  return function(source) {
    return function(sink) {
      var state = [!1, talkbackPlaceholder, talkbackPlaceholder];
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          if (state[0]) {
            return 0;
          } else {
            state[0] = !0;
            state[2](1);
            return sink(0);
          }
        } else if (signal.tag) {
          if (state[0]) {
            return 0;
          } else {
            return sink(signal);
          }
        } else {
          state[1] = signal[0];
          return _1(notifier, function(signal) {
            if ('number' == typeof signal) {
              return 0;
            } else if (signal.tag) {
              state[0] = !0;
              state[1](1);
              return sink(0);
            } else {
              var innerTb = signal[0];
              state[2] = innerTb;
              return innerTb(0);
            }
          });
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (state[0]) {
              return 0;
            } else if (signal) {
              state[0] = !0;
              state[1](1);
              return state[2](1);
            } else {
              return state[1](0);
            }
          }
        ])
      );
    };
  };
};

var takeWhile$2 = function takeWhile(f) {
  return function(source) {
    return function(sink) {
      var ended = [!1];
      var talkback = [talkbackPlaceholder];
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          if (ended[0]) {
            return 0;
          } else {
            ended[0] = !0;
            return sink(0);
          }
        } else if (signal.tag) {
          if (ended[0]) {
            return 0;
          } else if (f(signal[0])) {
            return sink(signal);
          } else {
            ended[0] = !0;
            sink(0);
            return talkback[0](1);
          }
        } else {
          talkback[0] = signal[0];
          return sink(signal);
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (ended[0]) {
              return 0;
            } else if (signal) {
              ended[0] = !0;
              return talkback[0](1);
            } else {
              return talkback[0](0);
            }
          }
        ])
      );
    };
  };
};

var publish$2 = function publish(source) {
  var state = [talkbackPlaceholder, !1];
  _1(source, function(signal) {
    if ('number' == typeof signal) {
      state[1] = !0;
      return 0;
    } else if (signal.tag) {
      if (state[1]) {
        return 0;
      } else {
        return state[0](0);
      }
    } else {
      var x = signal[0];
      state[0] = x;
      return x(0);
    }
  });
  return [
    function(param) {
      if (state[1]) {
        return 0;
      } else {
        state[1] = !0;
        return state[0](1);
      }
    }
  ];
};

var subscribe$2 = subscribe;

var forEach$2 = function forEach(f) {
  return function(source) {
    subscribe(f)(source);
    return 0;
  };
};

var toArray$2 = function toArray(source) {
  var state = [new Array(), talkbackPlaceholder, void 0, !1];
  _1(source, function(signal) {
    if ('number' == typeof signal) {
      state[3] = !0;
      return 0;
    } else if (signal.tag) {
      state[0].push(signal[0]);
      return state[1](0);
    } else {
      var x = signal[0];
      state[1] = x;
      return x(0);
    }
  });
  if (!state[3]) {
    state[1](1);
  }
  return state[0];
};

var debounce$2 = function debounce(f) {
  return function(source) {
    return function(sink) {
      var gotEndSignal = [!1];
      var id = [void 0];
      var $$clearTimeout$1 = function(param) {
        var match = id[0];
        if (void 0 !== match) {
          id[0] = void 0;
          clearTimeout(valFromOption(match));
          return 0;
        } else {
          return 0;
        }
      };
      return _1(source, function(signal) {
        if ('number' == typeof signal) {
          gotEndSignal[0] = !0;
          if (void 0 !== id[0]) {
            return 0;
          } else {
            return sink(0);
          }
        } else if (signal.tag) {
          $$clearTimeout$1();
          id[0] = some(
            setTimeout(function(param) {
              id[0] = void 0;
              sink(signal);
              if (gotEndSignal[0]) {
                return sink(0);
              } else {
                return 0;
              }
            }, f(signal[0]))
          );
          return 0;
        } else {
          var tb = signal[0];
          return sink(
            __(0, [
              function(signal) {
                if (signal) {
                  $$clearTimeout$1();
                  return tb(1);
                } else {
                  return tb(signal);
                }
              }
            ])
          );
        }
      });
    };
  };
};

var delay$2 = function delay(wait) {
  return function(source) {
    return function(sink) {
      var state = [talkbackPlaceholder, 0, !1];
      _1(source, function(signal) {
        var exit = 0;
        if ('number' == typeof signal || signal.tag) {
          exit = 1;
        } else {
          state[0] = signal[0];
          return 0;
        }
        if (1 === exit) {
          if (state[2]) {
            return 0;
          } else {
            state[1] = (state[1] + 1) | 0;
            setTimeout(function(param) {
              if (state[2] && 0 === state[1]) {
                sink(0);
              } else {
                state[1] = (state[1] - 1) | 0;
              }
              return sink(signal);
            }, wait);
            return 0;
          }
        }
      });
      return sink(
        __(0, [
          function(signal) {
            if (signal) {
              state[2] = !0;
              if (0 === state[1]) {
                return sink(0);
              } else {
                return 0;
              }
            } else if (state[2]) {
              return 0;
            } else {
              return state[0](signal);
            }
          }
        ])
      );
    };
  };
};

var throttle$2 = function throttle(f) {
  return function(source) {
    return function(sink) {
      var skip = [!1];
      var id = [void 0];
      var $$clearTimeout$1 = function(param) {
        var match = id[0];
        if (void 0 !== match) {
          clearTimeout(valFromOption(match));
          return 0;
        } else {
          return 0;
        }
      };
      return _1(source, function(signal) {
        if ('number' == typeof signal) {
          $$clearTimeout$1();
          return sink(0);
        } else if (signal.tag) {
          if (skip[0]) {
            return 0;
          } else {
            skip[0] = !0;
            $$clearTimeout$1();
            id[0] = some(
              setTimeout(function(param) {
                id[0] = void 0;
                skip[0] = !1;
                return 0;
              }, f(signal[0]))
            );
            return sink(signal);
          }
        } else {
          var tb = signal[0];
          return sink(
            __(0, [
              function(signal) {
                if (signal) {
                  $$clearTimeout$1();
                  return tb(1);
                } else {
                  return tb(signal);
                }
              }
            ])
          );
        }
      });
    };
  };
};

var toPromise$2 = toPromise$1;

var interval$2 = function interval(p) {
  return function(sink) {
    var i = [0];
    var id = setInterval(function(param) {
      var num = i[0];
      i[0] = (i[0] + 1) | 0;
      return sink(__(1, [num]));
    }, p);
    return sink(
      __(0, [
        function(signal) {
          if (signal) {
            clearInterval(id);
            return 0;
          } else {
            return 0;
          }
        }
      ])
    );
  };
};

var fromDomEvent$2 = function fromDomEvent(element, $$event) {
  return function(sink) {
    var addEventListener = function(element, event, handler) {
      element.addEventListener(event, handler);
    };
    var removeEventListener = function(element, event, handler) {
      element.removeEventListener(event, handler);
    };
    return fromListener(
      function(handler) {
        return _3(addEventListener, element, $$event, handler);
      },
      function(handler) {
        return _3(removeEventListener, element, $$event, handler);
      }
    )(sink);
  };
};

var fromListener$2 = fromListener;

var fromPromise$2 = function fromPromise(promise) {
  return function(sink) {
    var ended = [!1];
    promise.then(function(value) {
      if (!ended[0]) {
        sink(__(1, [value]));
        sink(0);
      }
      return Promise.resolve(0);
    });
    return sink(
      __(0, [
        function(signal) {
          if (signal) {
            ended[0] = !0;
            return 0;
          } else {
            return 0;
          }
        }
      ])
    );
  };
};

var fromObservable$2 = function fromObservable(input) {
  var observable = void 0 !== input[observableSymbol] ? input[observableSymbol]() : input;
  return function(sink) {
    var subscription = observable.subscribe({
      next: function(value) {
        return sink(__(1, [value]));
      },
      complete: function() {
        return sink(0);
      },
      error: function(param) {
        return 0;
      }
    });
    return sink(
      __(0, [
        function(signal) {
          if (signal) {
            return subscription.unsubscribe();
          } else {
            return 0;
          }
        }
      ])
    );
  };
};

var toObservable$2 = function toObservable(source) {
  var observable = {
    subscribe: function(observer) {
      var state = [talkbackPlaceholder, !1];
      _1(source, function(signal) {
        if ('number' == typeof signal) {
          state[1] = !0;
          return observer.complete();
        } else if (signal.tag) {
          if (state[1]) {
            return 0;
          } else {
            observer.next(signal[0]);
            return state[0](0);
          }
        } else {
          var x = signal[0];
          state[0] = x;
          return x(0);
        }
      });
      return {
        unsubscribe: function() {
          if (state[1]) {
            return 0;
          } else {
            state[1] = !0;
            return state[0](1);
          }
        }
      };
    }
  };
  observable[observableSymbol] = function(param) {
    return observable;
  };
  return observable;
};

var fromCallbag$2 = function fromCallbag(callbag) {
  return function(sink) {
    return callbag(0, function(signal, data) {
      switch (signal) {
        case 0:
          return sink(
            __(0, [
              function(talkbackSignal) {
                if (talkbackSignal) {
                  return data(2);
                } else {
                  return data(1);
                }
              }
            ])
          );

        case 1:
          return sink(__(1, [data]));

        case 2:
          return sink(0);
      }
    });
  };
};

var toCallbag$2 = function toCallbag(source) {
  return function(signal, data) {
    if (0 === signal) {
      return _1(source, function(signal) {
        if ('number' == typeof signal) {
          return data(2, 0);
        } else if (signal.tag) {
          return data(1, signal[0]);
        } else {
          var talkbackFn = signal[0];
          return data(0, function(talkback) {
            switch (talkback) {
              case 0:
                return 0;

              case 1:
                return talkbackFn(0);

              case 2:
                return talkbackFn(1);
            }
          });
        }
      });
    } else {
      return 0;
    }
  };
};

export {
  Types,
  buffer$2 as buffer,
  combine$2 as combine,
  concat$2 as concat,
  concatAll$2 as concatAll,
  concatMap$2 as concatMap,
  debounce$2 as debounce,
  delay$2 as delay,
  empty$2 as empty,
  filter$2 as filter,
  flatten$2 as flatten,
  forEach$2 as forEach,
  fromArray$2 as fromArray,
  fromCallbag$2 as fromCallbag,
  fromDomEvent$2 as fromDomEvent,
  fromList$2 as fromList,
  fromListener$2 as fromListener,
  fromObservable$2 as fromObservable,
  fromPromise$2 as fromPromise,
  fromValue$2 as fromValue,
  interval$2 as interval,
  make$2 as make,
  makeSubject$2 as makeSubject,
  map$2 as map,
  merge$2 as merge,
  mergeAll$2 as mergeAll,
  mergeMap$2 as mergeMap,
  never$2 as never,
  onEnd$2 as onEnd,
  onPush$2 as onPush,
  onStart$2 as onStart,
  pipe,
  publish$2 as publish,
  sample$2 as sample,
  scan$2 as scan,
  share$2 as share,
  skip$2 as skip,
  skipUntil$2 as skipUntil,
  skipWhile$2 as skipWhile,
  subscribe$2 as subscribe,
  switchAll$2 as switchAll,
  switchMap$2 as switchMap,
  take$2 as take,
  takeLast$2 as takeLast,
  takeUntil$2 as takeUntil,
  takeWhile$2 as takeWhile,
  tap$2 as tap,
  throttle$2 as throttle,
  toArray$2 as toArray,
  toCallbag$2 as toCallbag,
  toObservable$2 as toObservable,
  toPromise$2 as toPromise
};
